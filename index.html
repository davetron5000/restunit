<h1>RESTUnit</h1>

<p>RESTUnit is a set of Java classes that can be used to test REST services.  The data structure classes shall be serializable to and from a simple format, making the simplest way to create tests a matter of creating text files.  </p>

<p>Main features:</p>

<ul>
<li>Simple, human-readable/editable format for tests</li>
<li>Programmatic, JUnit, TestNG, and ANT interface to testing process</li>
<li>Results in JUnit format as option</li>
<li>Ability to derive tests based on the conventions of REST as well as tester-supplied custom derivations</li>
<li>Ability to customize result comparison with minimal custom code</li>
</ul>

<h1>Usage</h1>

<p>Currently, RESTUnit can be used as a TestNG test, with tests created programmatically.</p>

<p>You simply extend <code>TestNGRestUnit</code>, set up the <code>RestUnit</code> instance and implement <code>getTests()</code> to return your programmatically created tests.  Suppose you wanted to test that your REST service returns a particular XML document when you request <code>/rest/pictures</code> and that it sends a 401 when you try to PUT there:</p>

<pre><code>public class PicturesTests extends TestNGRestUnit
{
    public PicturesTests()
    {
        super();
        setRestUnit(new RestUnit());
        getRestUnit().getExecutor().setHttp(new JavaHttp());
        getRestUnit().getExecutor().setBaseURL("http://your.domain.com/rest");
    }

    public Set&lt;RestTest&gt; getTests()
    {
        Set&lt;RestTest&gt; tests = new HashSet&lt;RestTest&gt;();

        tests.add(createGetTest());
        tests.add(createPutTest());

        return tests.
    }

    private RestTest createGetTest()
    {
        RestTest test = new RestTest();
        test.setURL("/pictures");
        GetCall get = new GetCall();
        get.setMethod("GET");
        get.setName("GET to /pictures, which is allowed");
        BodyResponse response = new BodyResponse();
        response.setContentType(new ContentType("text/xml","UTF-8"));
        response.setStatusCode(200);
        response.getRequiredHeaders().put("Last-Modified");
        response.getRequiredHeaders().put("ETag");
        String data = "&lt;pictures&gt;" +
            "&lt;picture&gt;&lt;name&gt;foo&lt;/name&gt;&lt;location&gt;/pictures/foo.jpg&lt;/location&gt;&lt;/picture&gt;" +
            "&lt;picture&gt;&lt;name&gt;bar&lt;/name&gt;&lt;location&gt;/pictures/bar.jpg&lt;/location&gt;&lt;/picture&gt;" +
            "&lt;picture&gt;&lt;name&gt;The Great Foo&lt;/name&gt;&lt;location&gt;/pictures/great_foo.jpg&lt;/location&gt;&lt;/picture&gt;" +
            "&lt;/pictures&gt;";
        response.setBody(data.getBytes("UTF-8"));
        get.setResponse(response);
        test.addTest(get);
        return test;
    }

    private RestTest createPutTest()
    {
        RestTest test = new RestTest();
        test.setURL("/pictures");
        RestCall put = new RestCall();
        put.setMethod("PUT");
        put.setName("PUT to /pictures, which isn't allowed");
        RestCallResponse response = new RestCallResponse();
        response.setStatusCode(401);
        put.setResponse(response);
        test.addTest(put);
        return test;
    }
}
</code></pre>

<p>This will run two seprate tests.</p>

<p>Granted, this seems actually slightly more work than just using an HTTP client.  The intention of RESTUnit is that you should not normally have to create tests programmatically, nor should you have to configure your test environment programmatically.  Further, RESTUnit will provide a means of deriving tests.  Taking the above example, and assuming our service supports the standard features of HTTP and REST, we could derive several tests:</p>

<ul>
<li>A version of the GET test that takes the returned <code>ETag</code> and does a conditional GET</li>
<li>A version of the GET test that takes the returned <code>Last-Modified</code> and does a conditional GET</li>
<li>A version of the GET test that does the same request via HEAD and verifies that the headers are the same but that there is no body.</li>
<li>A version of the PUT test that tunnels the request over POST via the <code>X-HTTP-Override</code> header.</li>
</ul>

<h1>Details/Discussion</h1>

<h2>Test Form</h2>

<p>A REST test is much simpler than an arbitrary unit test.  It is a matter of HTTP requests and responses.</p>

<p>A test of a REST service endpoint (which would be a resource, identified by a URL) is a series of REST calls.  This could be simply one call (a GET to a resource that should return known data), or a more complex interaction of PUTing a new resource to the server, GETing that resource to see if it was received and DELETEing it to leave the remote data store in a known state.</p>

<h3>REST Call</h3>

<p>We'll use the term "Call" to be one HTTP request and response cycle.  </p>

<p>The request can be as simple as:</p>

<ul>
<li>URL</li>
<li>Method (GET/POST/PUT/DELETE/HEAD)</li>
<li>parameters</li>
<li>headers</li>
</ul>

<p>The response is equally simple:</p>

<ul>
<li>Status Code</li>
<li>Response content</li>
<li>Response headers</li>
</ul>

<p>We could represent such a call in <a href="http://en.wikipedia.org/wiki/YAML">YAML</a>  as so:</p>

<pre><code>url: /accounts/Initech/users
method: GET
parameters:
    - name: *bob*
    - sort: { ascending: true, by: last name}
headers:
    If-None-Match: 71783837e5a4c543bce456
response:
    status: 200
    body: &lt;users&gt;&lt;user id="34"&gt;&lt;name&gt;Bob 1&lt;/name&gt;&lt;/user&gt;&lt;users id="556"&gt;&lt;name&gt;Bob 2&lt;/name&gt;&lt;/user&gt;&lt;/users&gt;
    headers:
        Content-Type: { value: text/xml }
        Last-Modified: { required: true }
</code></pre>

<h3>Rest Test</h3>

<p>A full-on test would be a series of calls.  This could easily be described using the format above.  Further, since a series of calls is made against the same URL, we can promote the URL up to the test level.
Calls could override the URL as needed (as for a POST that would create a new URL):</p>

<pre><code>url: /accounts/Initech/users/bolton
- POST:
    - url: /accounts/Initech/users
    - stuff to put data
- GET: # uses the parent URL
    - stuff for the get test
- DELETE
- GET
    response:
        status: 404
</code></pre>

<p>So far, this just looks like a simplistic way to test any HTTP endpoint.  However, we can use this tests to derive new ones, based upon the conventions of REST (or conventions your REST service provides), such as:
* URLs responding to GET should respond to HEAD in the same way, save for the body
* URLs responding to GET should send <code>ETag</code> and <code>Last-Modified</code> headers to allow for conditional gets
* URLs responding to GET should send a 304 if <code>If-None-Match</code> or <code>If-Modified-Since</code> headers are set to indicate the client has up-to-date data.
* PUT and DELETE methods may be tunneled over POST for clients/configurations that don't support it</p>

<p>Such derived tests would be virtually identical to their base counterparts, so why copy them?  Consider the URL <code>/accounts/Initech/users/bob/profile.xml</code> and supposed your REST service only sends ETags for JPEGs.  You could test this via:</p>

<pre><code>url: /accounts/Initech/users/bob/profile.xml
- GET:
    respondsToIfNonMatch: false
    response:
        status: 200
        content: &lt;profile id="234"&gt;&lt;name&gt;Mike Bolton&lt;/name&gt;&lt;/profile&gt;
        contentType: text/xml
</code></pre>

<p>We could then derive this test:</p>

<pre><code>url: /accounts/Initech/users/bob/profile.xml
- GET:
    respondsToIfNonMatch: false
    response:
        status: 200
        content: &lt;profile id="234"&gt;&lt;name&gt;Mike Bolton&lt;/name&gt;&lt;/profile&gt;
        contentType: text/xml
        headers:
            Last-Modified {required: true}
- GET:
    respondsToIfNonMatch: false
    respondsToIfModifiedSince: false
    headers:
        If-Modified-Since: $Last-Modified$ # indicates to use the last tests response header
    response:
        status: 304
        content: &lt;profile id="234"&gt;&lt;name&gt;Mike Bolton&lt;/name&gt;&lt;/profile&gt;
        contentType: text/xml
- HEAD:
    response:
        status: 200
        # body omitted means no body should be returned 
- HEAD:
    headers:
        If-Modified-Since: 2008-01-01
    response:
        status: 304
</code></pre>

<h2>Comparing Results</h2>

<p>In a lot of cases, simple byte-for-byte comparisons of results could work.  Out of the box, we can provide:
* Ensure equality of status codes
* Check that certain headers are included (regardless of value)
* Check that certain headers are <em>not</em> included
* Check that certain headers are included and have a specific value
* byte-for-byte comparison of body received and body expected.</p>

<p>Further, we can provide a means of customizing the comparison.  For example, a user may be expecting XML that has temporal data in it.  If this can be ignored for the sake of the test, this should be easy to accomplish.</p>

<h2>Output Format</h2>

<p>JUnit's XML results file seems to be ubiquitous.  RESTUnit must output that so that integration with tools like Bamboo are possible.  Support for TestNG's output format may also be desirable, though this could be most easily achieved by allow RESTUnit to run as a TestNG test. Making up a new output format is probably NOT desirable.</p>

<h1>Links</h1>
<ul>
    <li><a href="javadoc">Javadoc</a></li>
    <li><a href="http://www.github.com/davetron5000/restunit">Git repository</a></li>
</ul>
